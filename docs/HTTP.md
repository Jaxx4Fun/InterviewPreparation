# HTTP
## 历史
### HTTP 1.x
一次请求需要4*RTT
- 基于TCP，三次握手需要1.5*RTT
- TLS连接需要1.5*RTT
    1. 浏览器给服务器发送的Client Hello消息（一去）首长好，我支持1.2版本，加密套件列表1、2、3…，以及我的随机码N1，请出示您的证件。
    2. 服务器给浏览器发送的Server Hello消息（二回）同志们好，那就1.2版本通信吧，加密套件我选用1，我的随机码N2，ECDHE密钥交换素材2，这是我的证件。同志们辛苦了！
    3. 浏览器给服务器发送的Key Exchange消息（三去）为人民服务！ 嘴里虽这么说着，私下还要偷偷验证首长的证件是否伪造的。首长证书验证成功之后，还要给首长会话呢？会话内容如下：首长辛苦了！ 我的ECDHE密钥交换素材1，接下来我发给您的消息都要加密了（Change Spec）。

    作者：车小胖
    链接：https://www.zhihu.com/question/302412059/answer/533223530
    来源：知乎
- HTTP通信请求返回1*RTT
### HTTP /2
对同一个服务器的请求，复用TCP连接，但是可能会出现头部阻塞的情况
### HTTP /3
改用UDP，QUIC基于UDP进行类似TCP的可靠传输机制、TLS加密、HTTP /2流量复用。QUIC的Session ID会被浏览器缓存，如果再次打开页面，则直接拿到加密参数，完成加密，省去了加密以及之前的RTT时间，所以只有一次HTTP请求与返回的耗时1*RTT
## TLS
### 历史
#### 无加密
#### 对称密钥
A、B双方约定好对称密钥（加密解密都用同一个）
##### cons
- 随着计算机性能的发展，短密钥能在短时间内被暴力破解，使得密钥的长度需要一步步加长
- 为了防止中间人窃取密钥破解信息，所以密钥不能通过网络传输；一旦密钥泄漏，双方则需要线下协商一个新的密钥。
#### 非对称加密
非对称加密使用两个密钥，公钥和私钥。一个用来加密，另一个用来解密。

具体使用中，A、B双方**各有一个公钥和私钥**；A给B发数据，则先用A的私钥加密数据的hash值，再用B的公钥加密数据，将这两个信息加一些其他信息，发送给B。B收到后，先用B的私钥解密数据，然后计算数据的hash，再用A的公钥解密A发来的hash值，对比是否一致。

在A、B通过网络交换各自公钥的过程中，存在中间人M，给双方各自发一个假的公钥，A、B双方就会用假公钥进行交流。对于A而言，M就相当于B；对B而言，M就相当于A

##### cons
- 需要确保public key的真实性
##### 常见的算法
- RSA

#### CA
找一个可靠的中间人CA（Certificate Authority），B把自己的public key和其他信息交给CA，CA用自己的private key加密这些信息，这些信息被承认B的数字证书。A、B双方交换数字证书，而后通过CA证书中的CA的public key来解密各自的public key
CA将自己的CA证书放在浏览器和操作系统中，这确保了CA证书解密出来的A、B的public key肯定是经过CA认证的。

### 现代实际使用
- CA体系交换A、B双发的public key
- 通过上一步建立的加密通道，交换对称加密的密钥
- 之后用对称加密的密钥，加密正常通信